import xml.etree.ElementTree as ET
from jinja2 import Environment, FileSystemLoader
import os
import argparse
import subprocess
import tempfile
from pygvariant import GVariantValueConverter, GVariantParser, to_gschema
from dataclasses import asdict, dataclass, field, is_dataclass
from typing import Any, Tuple
import yaml
import traceback
MODULE_VERSION = "1.1.0"


@dataclass
class EntryData:
    name: str
    default: Any


@dataclass
class SchemaOption:
    description: list[str]
    type: str
    default: Any


@dataclass
class SchemaEntry:
    name: str
    gtype: str
    options: SchemaOption
    ansible_type: str


@dataclass
class SchemaModule:
    module: str
    short_description: str
    description: str
    author = ["Autogenerated by ansible-gnome-lockdown"]
    version_added: str = MODULE_VERSION
    options: list[SchemaOption] = field(default_factory=list)


def gsettings_to_ansible_type(gsettings_type):
    """Maps GSettings type to Ansible type."""
    mapping = {"b": "bool", "i": "int", "s": "str", "a": "list", "d": "float"}
    return mapping.get(gsettings_type, "str")


def sanitize_description(desc: str) -> str:

    clean_description = desc.strip()

    to_replace = {"''": "'", "\u201c": '"', "\u201d": '"', "\u2019": '"', '"': "'"}
    for old, new in to_replace.items():

        clean_description = clean_description.replace(old, new)

    clean_description = (
        clean_description.removeprefix("'")
        .removesuffix("'")
        .removeprefix('"')
        .removesuffix('"')
    )
    return clean_description

def sanitize_default(parsed_default):

    # if it's a native str make sure we strip quotes.
    if isinstance(parsed_default, str):
        parsed_default = parsed_default.replace("'", "").strip()

    # Check if it's a flat tuple, turn it into a str
    if isinstance(parsed_default, Tuple):
        parsed_default = str(parsed_default).strip()

    # Check if it's a list and it contains tuples. Tuples in yaml aren't really supported natively.
    if isinstance(parsed_default, list) and any(
        isinstance(element, tuple) for element in parsed_default
    ):
        new_default = []
        for elem in parsed_default:
            if isinstance(elem, Tuple):
                new_default.append(str(elem).strip())
            else:
                new_default.append(elem)
        parsed_default = new_default

    return parsed_default


def parse_schema(xml_file):
    """Parses a GSettings XML schema and extracts relevant information."""
    tree = ET.parse(xml_file)
    root = tree.getroot()
    schemas = []

    # Check if the root is a schemalist or a single schema
    if root.tag == "schemalist":
        schema_nodes = root.findall("schema")
    else:
        schema_nodes = [root]

    for schema_node in schema_nodes:
        schema_id = schema_node.get("id")
        if not schema_id:
            continue  # Skip if no ID

        schema_path = schema_node.get("path")
        schema_entries = []
        schema_examples = []

        for key_node in schema_node.findall("key"):
            key_name = key_node.get("name")
            key_type = key_node.get("type") or "s"
            ansible_type = gsettings_to_ansible_type(key_type)
            default_node = key_node.find("default")

            if default_node is not None and default_node.text is not None:
                key_default = " ".join(default_node.text.strip("'").split())
            else:
                key_default = "''"

            if ansible_type == "bool":
                key_default = key_default.lower()

            if key_default in ["true", "false"]:
                ansible_type = "bool"

            summary_node = key_node.find("summary")

            if summary_node is not None and summary_node.text is not None:
                key_summary = summary_node.text.strip()
            else:
                key_summary = "Summary - Schema Blank"

            description_node = key_node.find("description")
            if description_node is not None and description_node.text is not None:
                key_description = sanitize_description(description_node.text)
            else:
                key_description = "Description - Schema Blank"

            converter = GVariantValueConverter()
            print(f"Default {key_default}")
            parsed_default = converter.parse_value_string(key_default, key_type)

            parsed_default = sanitize_default(parsed_default)

            # Create the actual entry
            entry_options = SchemaOption(
                [key_summary, key_description],
                ansible_type,
                parsed_default,
            )
            entry = SchemaEntry(key_name, key_type, entry_options, ansible_type)
            schema_entries.append(entry)

            example = {f"{key_name}": parsed_default}
            schema_examples.append(example)

        schemas.append(
            {
                "id": schema_id,
                "path": schema_path,
                "entries": schema_entries,
                "examples": schema_examples,
            }
        )
    return schemas


def to_yaml(data):
    return yaml.safe_dump(data, sort_keys=False, default_flow_style=False)


def generate_module(schema_data, template_file, output_dir):
    """Generates an Ansible module from schema data and a Jinja2 template."""
    schema_id = schema_data["id"]
    schema_path = schema_data["path"]
    entries = schema_data["entries"]
    examples = schema_data["examples"]
    # Module name from schema id
    raw_module_name = schema_id
    module_name = schema_id.replace(".", "_").replace("-", "_").lower()
    # Set up Jinja2 environment
    env = Environment(
        loader=FileSystemLoader(os.path.dirname(template_file)),
        trim_blocks=True,
        lstrip_blocks=True,
    )
    env.filters["to_yaml"] = to_yaml
    env.filters["repr"] = repr
    template = env.get_template(os.path.basename(template_file))

    # Render the template
    module_content = template.render(
        module_name=module_name.replace("-", "_"),
        raw_module_name=raw_module_name,
        schema_id=schema_id,
        schema_path=schema_path,
        entries=entries,
        examples=examples,
    )
    # print(module_content)
    # Write the output file
    output_path = os.path.join(output_dir, module_name.replace("-", "_") + ".py")
    os.makedirs(output_dir, exist_ok=True)
    with open(output_path, "w") as f:
        f.write(module_content)

    print(f"Successfully generated module: {output_path}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate Ansible modules from GSettings schemas."
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--schema", help="Path to a single GSettings XML schema file.")
    group.add_argument(
        "--schema-list",
        help="Path to a file containing a list of schema URLs or file paths.",
    )

    parser.add_argument(
        "--template",
        default="base_module_template.j2",
        help="Path to the Jinja2 template file.",
    )
    parser.add_argument(
        "--output-dir",
        default="generated_modules",
        help="Directory to save the generated modules.",
    )

    args = parser.parse_args()

    schemas_to_process = []
    if args.schema:
        schemas_to_process.append(args.schema)
    else:
        try:
            with open(args.schema_list, "r") as f:
                schemas_to_process = [line.strip() for line in f if line.strip()]
        except FileNotFoundError:
            print(f"Error: Schema list file not found at '{args.schema_list}'")
            exit(1)

    for schema_location in schemas_to_process:
        schema_file_to_process = None
        temp_file = None

        if schema_location.startswith(("http://", "https://")):
            try:
                print(f"Downloading schema from: {schema_location}")
                # Create a temporary file to store the downloaded schema
                temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".xml")
                schema_file_to_process = temp_file.name

                # Use curl to download the file
                subprocess.run(
                    [
                        "curl",
                        "-A",
                        "Mozilla/5.0",
                        "-o",
                        schema_file_to_process,
                        schema_location,
                    ],
                    check=True,
                    capture_output=True,
                    text=True,
                )
            except subprocess.CalledProcessError as e:
                print(
                    f"Warning: Failed to download schema from '{schema_location}': {e.stderr}, skipping."
                )
                if temp_file:
                    os.remove(schema_file_to_process)
                continue
            except Exception as e:
                print(
                    f"Warning: An unexpected error occurred while downloading '{schema_location}': {e}, skipping."
                )
                if temp_file:
                    os.remove(schema_file_to_process)
                continue
        else:
            schema_file_to_process = schema_location

        try:
            print(f"Processing schema file: {schema_file_to_process}")
            schemas = parse_schema(schema_file_to_process)
            for schema_data in schemas:
                print(f"  Generating module for schema: {schema_data['id']}")
                if len(schema_data["entries"]) < 1:
                    print(f"No schema entries found for {schema_data['id']}. Skipping.")
                    continue
                if "deprecated" not in schema_data["id"]:
                    generate_module(schema_data, args.template, args.output_dir)
                else:
                    print(f"Depreciated schema {schema_data['id']} found. Skipping.")
                    continue
        except FileNotFoundError:
            print(
                f"Warning: Schema file not found at '{schema_file_to_process}', skipping."
            )
        except Exception as e:
            print(
                f"Warning: Failed to process schema file '{schema_file_to_process}': {traceback.print_exc()}, skipping."
            )
        finally:
            # Clean up the temporary file if one was created
            if temp_file:
                os.remove(schema_file_to_process)
