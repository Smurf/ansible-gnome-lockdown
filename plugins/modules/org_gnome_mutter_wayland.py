#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2023, Jules
# All rights reserved.

from __future__ import absolute_import, division, print_function
__metaclass__ = type

DOCUMENTATION = r'''
---
module: org_gnome_mutter_wayland
short_description: Manages GNOME GSettings for org.gnome.mutter.wayland
description:
  - >
    This module allows for the configuration of GSettings keys within the 'org.gnome.mutter.wayland' schema.
  - >
    It supports setting default values and locking keys to enforce system-wide policies.
author:
  - Autogenerated by ansible-gnome-lockdown
version_added: "1.1.0"
options:
  xwayland-allow-grabs:
    description:
    - Allow X11 grabs to lock keyboard focus with Xwayland
    - "Allow all keyboard events to be routed to X11 'override redirect'\n        windows\
      \ with a grab when running in Xwayland.\n\n        This option is to support X11\
      \ clients which map an 'override redirect'\n        window (which do not receive\
      \ keyboard focus) and issue a keyboard\n        grab to force all keyboard events\
      \ to that window.\n\n        This option is seldom used and has no effect on regular\
      \ X11 windows\n        which can receive keyboard focus under normal circumstances.\n\
      \n        For a X11 grab to be taken into account under Wayland, the client must\n\
      \        also either send a specific X11 ClientMessage to the root window or be\n\
      \        among the applications allowed in key 'xwayland-grab-access-rules'."
    type: bool
    default: false

  xwayland-allow-grabs_locked:
    description:
    - >
      If set to true, locks the 'xwayland-allow-grabs' key to prevent user modification.
    type: bool
    default: false
  xwayland-grab-access-rules:
    description:
    - Xwayland applications allowed to issue keyboard grabs
    - "List the resource names or resource class of X11 windows either\n        allowed\
      \ or not allowed to issue X11 keyboard grabs under Xwayland.\n\n        The resource\
      \ name or resource class of a given X11 window can be\n        obtained using the\
      \ command 'xprop WM_CLASS'.\n\n        Wildcards '*' and jokers '?' in the values\
      \ are supported.\n\n        Values starting with '!' are denied, which has precedence\
      \ over\n        the list of values allowed, to revoke applications from the default\n\
      \tsystem list.\n\n        The default system list includes the following applications:\n\
      \n        'gnome-boxes,remote-viewer,virt-viewer,virt-manager,vinagre,vncviewer,Xephyr'\n\
      \n        Users can break an existing grab by using the specific keyboard\n    \
      \    shortcut defined by the keybinding key 'restore-shortcuts'."
    type: str
    default: []

  xwayland-grab-access-rules_locked:
    description:
    - >
      If set to true, locks the 'xwayland-grab-access-rules' key to prevent user modification.
    type: bool
    default: false
  xwayland-disable-extension:
    description:
    - Disable selected X extensions in Xwayland
    - "This option disables the selected X extensions in Xwayland if\n        Xwayland\
      \ was built with support for those X extensions.\n\n        This option has no effect\
      \ if Xwayland was built without support\n        for the selected extensions.\n\n\
      \        Xwayland needs to be restarted for this setting to take effect."
    type: str
    default: '[]'

  xwayland-disable-extension_locked:
    description:
    - >
      If set to true, locks the 'xwayland-disable-extension' key to prevent user modification.
    type: bool
    default: false
  xwayland-allow-byte-swapped-clients:
    description:
    - Allow X11 clients with a different endianness to connect to Xwayland
    - "Allow connections from clients with an endianness different to that\n\tof Xwayland.\n\
      \n\tThe X server byte-swapping code is a huge attack surface, much of\n\tthat code\
      \ in Xwayland is prone to security issues.\n\n\tThe use-case of byte-swapped clients\
      \ is very niche, and disabled by\n\tdefault in Xwayland.\n\n\tEnable this option\
      \ to instruct Xwayland to accept connections from\n\tX11 clients with a different\
      \ endianness.\n\n        This option has no effect if Xwayland does not support\
      \ the command\n\tline option +byteswappedclients/-byteswappedclients to control\
      \ that\n\tsetting.\n\n        Xwayland needs to be restarted for this setting to\
      \ take effect."
    type: bool
    default: false

  xwayland-allow-byte-swapped-clients_locked:
    description:
    - >
      If set to true, locks the 'xwayland-allow-byte-swapped-clients' key to prevent user modification.
    type: bool
    default: false
'''

EXAMPLES = r'''
- name: Configure and lock GNOME desktop settings for org.gnome.mutter.wayland
  org_gnome_mutter_wayland:
    xwayland-allow-grabs: false

    xwayland-grab-access-rules: []

    xwayland-disable-extension: '[]'

    xwayland-allow-byte-swapped-clients: false

'''

RETURN = r'''
# Default return values
'''

from ansible.module_utils.basic import AnsibleModule
import os
import configparser

def main():
    """Main function for the Ansible module."""
    # We have to do gross stuff with the bools here.
    keys_spec = {
        'xwayland-allow-grabs': {
            'default': False,
            'type': 'bool',
            'gtype':'b',
        },
        'xwayland-grab-access-rules': {
            'default': [],
            'type': 'str',
            'gtype':'as',
        },
        'xwayland-disable-extension': {
            'default': '[]',
            'type': 'str',
            'gtype':'s',
        },
        'xwayland-allow-byte-swapped-clients': {
            'default': False,
            'type': 'bool',
            'gtype':'b',
        },
    }

    argument_spec = {}
    for key_name, spec in keys_spec.items():
        argument_spec[key_name] = spec
        argument_spec[f"{key_name}_locked"] = {'type': 'bool', 'default': False}

    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True
    )

    changed = False

    settings_dir = "/etc/dconf/db/local.d"
    locks_dir = os.path.join(settings_dir, "locks")

    settings_file_path = os.path.join(settings_dir, "00-ansible-org.gnome.mutter.wayland")
    lock_file_path = os.path.join(locks_dir, "ansible-org.gnome.mutter.wayland")

    schema_full_path = "/org/gnome/mutter/wayland/"
    config_section = schema_full_path.strip('/')

    os.makedirs(settings_dir, exist_ok=True)
    os.makedirs(locks_dir, exist_ok=True)

    # Idempotency: Read current settings
    current_settings = configparser.ConfigParser()
    if os.path.exists(settings_file_path):
        current_settings.read(settings_file_path)

    # Idempotency: Read current locks from our dedicated lock file
    current_locks = []
    if os.path.exists(lock_file_path):
        with open(lock_file_path, 'r') as f:
            current_locks = [line.strip() for line in f if line.strip()]

    # Prepare settings and locks based on module parameters
    new_settings = configparser.ConfigParser()
    new_settings.add_section(config_section)
    new_locks = []

    for key_name, spec in keys_spec.items():
        param_value = module.params[key_name]
        param_locked = module.params[f"{key_name}_locked"]

        if spec['type'] == 'bool':
            setting_value = str(param_value).lower()
        elif spec['type'] == 'str':
            setting_value = f'{param_value}'
        else:
            setting_value = str(param_value)

        new_settings.set(config_section, key_name, setting_value)

        if param_locked:
            new_locks.append(f"{schema_full_path}{key_name}")

    # Check for changes
    settings_changed = False
    if not current_settings.has_section(config_section) or \
       (current_settings.has_section(config_section) and dict(current_settings.items(config_section)) != dict(new_settings.items(config_section))):
        settings_changed = True

    locks_changed = sorted(new_locks) != sorted(current_locks)

    if settings_changed or locks_changed:
        changed = True

    if changed and not module.check_mode:
        # Write settings file
        with open(settings_file_path, 'w') as f:
            new_settings.write(f, space_around_delimiters=False)

        # Manage the dedicated lock file
        if new_locks:
            with open(lock_file_path, 'w') as f:
                for lock_key in new_locks:
                    f.write(f"{lock_key}\n")
        elif os.path.exists(lock_file_path):
            os.remove(lock_file_path)

        # Update dconf database
        module.run_command(["dconf", "update"], check_rc=True)

    module.exit_json(changed=changed)

if __name__ == '__main__':
    main()
