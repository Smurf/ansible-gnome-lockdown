#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2023, Jules
# All rights reserved.

from __future__ import absolute_import, division, print_function
__metaclass__ = type

DOCUMENTATION = r'''
---
module: org_gnome_desktop_media-handling
short_description: Manages GNOME GSettings for org.gnome.desktop.media-handling
description:
  - >
    This module allows for the configuration of GSettings keys within the 'org.gnome.desktop.media-handling' schema.
  - >
    It supports setting default values and locking keys to enforce system-wide policies.
author:
  - Autogenerated by ansible-gnome-lockdown
version_added: "1.0.0"
options:
  automount:
    description:
      - >
        Whether to automatically mount media
      - >
        If set to true, then Nautilus will automatically mount media such as user-visible hard disks and removable media on start-up and media insertion.
    type: bool
    default: true
  automount_locked:
    description:
      - >
        If set to true, locks the 'automount' key to prevent user modification.
    type: bool
    default: false
  automount-open:
    description:
      - >
        Whether to automatically open a folder for automounted media
      - >
        If set to true, then Nautilus will automatically open a folder when media is automounted. This only applies to media where no known x-content/* type was detected; for media where a known x-content type is detected, the user configurable action will be taken instead.
    type: bool
    default: true
  automount-open_locked:
    description:
      - >
        If set to true, locks the 'automount-open' key to prevent user modification.
    type: bool
    default: false
  autorun-never:
    description:
      - >
        Never prompt or autorun/autostart programs when media are inserted
      - >
        If set to true, then Nautilus will never prompt nor autorun/autostart programs when a medium is inserted.
    type: bool
    default: true
  autorun-never_locked:
    description:
      - >
        If set to true, locks the 'autorun-never' key to prevent user modification.
    type: bool
    default: false
  autorun-x-content-start-app:
    description:
      - >
        List of x-content/* types where the preferred application will be launched
      - >
        List of x-content/* types for which the user have chosen to start an application in the preference capplet. The preferred application for the given type will be started on insertion on media matching these types.
    type: str
    default: "[ 'x-content/unix-software', 'x-content/ostree-repository' ]"
  autorun-x-content-start-app_locked:
    description:
      - >
        If set to true, locks the 'autorun-x-content-start-app' key to prevent user modification.
    type: bool
    default: false
  autorun-x-content-ignore:
    description:
      - >
        List of x-content/* types set to “Do Nothing”
      - >
        List of x-content/* types for which the user have chosen “Do Nothing” in the preference capplet. No prompt will be shown nor will any matching application be started on insertion of media matching these types.
    type: str
    default: []
  autorun-x-content-ignore_locked:
    description:
      - >
        If set to true, locks the 'autorun-x-content-ignore' key to prevent user modification.
    type: bool
    default: false
  autorun-x-content-open-folder:
    description:
      - >
        List of x-content/* types set to “Open Folder”
      - >
        List of x-content/* types for which the user have chosen “Open Folder” in the preferences capplet. A folder window will be opened on insertion of media matching these types.
    type: str
    default: []
  autorun-x-content-open-folder_locked:
    description:
      - >
        If set to true, locks the 'autorun-x-content-open-folder' key to prevent user modification.
    type: bool
    default: false
'''

EXAMPLES = r'''
- name: Configure and lock GNOME desktop settings for org.gnome.desktop.media-handling
  org_gnome_desktop_media-handling:
    automount: true
    automount_locked: true
    automount-open: true
    automount-open_locked: true
'''

RETURN = r'''
# Default return values
'''

from ansible.module_utils.basic import AnsibleModule
import os
import configparser

def main():
    """Main function for the Ansible module."""

    keys_spec = {
        'automount': {
            'type': 'bool',
            'default': True
        },
        'automount-open': {
            'type': 'bool',
            'default': True
        },
        'autorun-never': {
            'type': 'bool',
            'default': True
        },
        'autorun-x-content-start-app': {
            'type': 'str',
            'default': "[ 'x-content/unix-software', 'x-content/ostree-repository' ]"
        },
        'autorun-x-content-ignore': {
            'type': 'str',
            'default': []
        },
        'autorun-x-content-open-folder': {
            'type': 'str',
            'default': []
        },
    }

    argument_spec = {}
    for key_name, spec in keys_spec.items():
        argument_spec[key_name] = spec
        argument_spec[f"{key_name}_locked"] = {'type': 'bool', 'default': False}

    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True
    )

    changed = False

    settings_dir = "/etc/dconf/db/local.d"
    locks_dir = os.path.join(settings_dir, "locks")

    settings_file_path = os.path.join(settings_dir, "00-ansible-org_gnome_desktop_media-handling")
    lock_file_path = os.path.join(locks_dir, "ansible-org_gnome_desktop_media-handling")

    schema_full_path = "/org/gnome/desktop/media-handling/"
    config_section = schema_full_path.strip('/')

    os.makedirs(settings_dir, exist_ok=True)
    os.makedirs(locks_dir, exist_ok=True)

    # Idempotency: Read current settings
    current_settings = configparser.ConfigParser()
    if os.path.exists(settings_file_path):
        current_settings.read(settings_file_path)

    # Idempotency: Read current locks from our dedicated lock file
    current_locks = []
    if os.path.exists(lock_file_path):
        with open(lock_file_path, 'r') as f:
            current_locks = [line.strip() for line in f if line.strip()]

    # Prepare settings and locks based on module parameters
    new_settings = configparser.ConfigParser()
    new_settings.add_section(config_section)
    new_locks = []

    for key_name, spec in keys_spec.items():
        param_value = module.params[key_name]
        param_locked = module.params[f"{key_name}_locked"]

        if spec['type'] == 'bool':
            setting_value = str(param_value).lower()
        elif spec['type'] == 'str':
            setting_value = f"'{param_value}'"
        else:
            setting_value = str(param_value)

        new_settings.set(config_section, key_name, setting_value)

        if param_locked:
            new_locks.append(f"{schema_full_path}{key_name}")

    # Check for changes
    settings_changed = False
    if not current_settings.has_section(config_section) or \
       (current_settings.has_section(config_section) and dict(current_settings.items(config_section)) != dict(new_settings.items(config_section))):
        settings_changed = True

    locks_changed = sorted(new_locks) != sorted(current_locks)

    if settings_changed or locks_changed:
        changed = True

    if changed and not module.check_mode:
        # Write settings file
        with open(settings_file_path, 'w') as f:
            new_settings.write(f, space_around_delimiters=False)

        # Manage the dedicated lock file
        if new_locks:
            with open(lock_file_path, 'w') as f:
                for lock_key in new_locks:
                    f.write(f"{lock_key}\n")
        elif os.path.exists(lock_file_path):
            os.remove(lock_file_path)

        # Update dconf database
        module.run_command(["dconf", "update"], check_rc=True)

    module.exit_json(changed=changed)

if __name__ == '__main__':
    main()
